<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>biblio</title>
    <description></description>
    <link>http://molguin92.github.io/bibliography/bibliography/</link>
    <atom:link href="http://molguin92.github.io/bibliography/bibliography/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 20 Jun 2018 15:12:03 +0000</pubDate>
    <lastBuildDate>Wed, 20 Jun 2018 15:12:03 +0000</lastBuildDate>
    <generator>Jekyll v3.7.3</generator>
    
      <item>
        <title>Thread-level synthetic benchmarks for multicore systems</title>
        <description>&lt;p&gt;&lt;em&gt;This post refers to two papers &lt;a href=&quot;#Sen2015ThreadLevelSyntheticBenchmarks&quot;&gt;[1], [2]&lt;/a&gt; by the same authors.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Sen et al. present the &lt;a href=&quot;http://depend.cmpe.boun.edu.tr/tools.html&quot;&gt;MINIME&lt;/a&gt; benchmark synthesizer as a solution to the problem of generating accurate and efficient synthetic benchmarks for arbitrary workloads in general-purpose multicore systems.&lt;/p&gt;

&lt;p&gt;MINIME is based on two main principles. 
First, the automatic classification of multithreaded applications in so-called &lt;em&gt;parallel patterns&lt;/em&gt;, which describe the coarse-grained behavior of these applications in terms of how data is shared and workload distributed across the threads.
Examples of these patters are the &lt;em&gt;Divide and Conquer&lt;/em&gt; pattern, in which a task is recursively divided into smaller subtasks spread across threads, and the &lt;em&gt;Pipeline&lt;/em&gt; pattern, in which threads execute distinct tasks across segments of data in a parallel fashion, each thread feeding data forward to the next thread in a specified sequence when ready.&lt;/p&gt;

&lt;p&gt;Second, the characterization of the workload of each thread in the pattern using binary instrumentation. Specifically, they use Hardware Performance Counters to monitor four key metrics per application thread: &lt;em&gt;Instructions per Cycle&lt;/em&gt;, &lt;em&gt;Cache Miss Rate&lt;/em&gt;, &lt;em&gt;Branch Prediction Rate&lt;/em&gt; and finally &lt;em&gt;Communication to Computation Ratio&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Finally, the authors use these measurements to construct synthetic benchmarks which accurately mimic the original program behavior. 
These benchmarks consist of programs written in plain C which do not perform any real work, but rather just keep the CPU busy in a manner similar to the original application.&lt;/p&gt;

&lt;p&gt;The construction of the benchmarks is performed in the following way:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The correct number of threads is extracted from the coarse-grained parallel pattern recognition, along with start and end times for each thread.&lt;/li&gt;
  &lt;li&gt;Then, the synthetic workload for each thread is generated in iteratively:
    &lt;ul&gt;
      &lt;li&gt;The system starts with a &lt;em&gt;blank&lt;/em&gt; program for each thread.&lt;/li&gt;
      &lt;li&gt;For each iteration of the generation algorithm, the system selects the metric with the greatest error between synthetic and real workload and adds a section of code to decrease this error to the synthetic benchmark.
 For instance, if at a specific iteration for a thread, the number of &lt;em&gt;Instructions per Cycle&lt;/em&gt; for the synthetic benchmark is lower than for the real workload, the algorithm appends a slice of code which increases the number of instructions to the synthetic.
 Conversely, if the opposite were true (i.e. &lt;em&gt;Instructions per Cycle&lt;/em&gt; synthetic &amp;gt; original), the algorithm would add code to diminish the number of operations.
 This is repeated until the similarity for each metric between the synthetic benchmark and the real one reaches a previously set threshold.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;results&quot;&gt;Results&lt;/h3&gt;

&lt;p&gt;The authors present very promising results for a non-trivial number of different benchmarks, obtaining over 90% similarity for all of them (see figure below).&lt;/p&gt;

&lt;figure class=&quot;figure&quot;&gt;
  &lt;img src=&quot;/bibliography/assets/images/minime_results.gif&quot; alt=&quot;Results&quot; /&gt;
  
  &lt;figcaption&gt;Results: benchmarks and their similarity score between sinthetic and original.&lt;/figcaption&gt;
&lt;/figure&gt;
</description>
        <pubDate>Fri, 15 Jun 2018 00:00:00 +0000</pubDate>
        <link>http://molguin92.github.io/bibliography/bibliography/2018/thread-level-synthetic-benchmarks-for-multicore-systems/</link>
        <guid isPermaLink="true">http://molguin92.github.io/bibliography/bibliography/2018/thread-level-synthetic-benchmarks-for-multicore-systems/</guid>
        
        
      </item>
    
      <item>
        <title>Workload synthesis: Generating benchmark workloads from statistical execution profile</title>
        <description>&lt;p&gt;&lt;a href=&quot;#Kim2014WorkloadSynthesis&quot;&gt;[1]&lt;/a&gt; presents an approach to workload synthesis for arbitrary applications through the generation of statistically representative models. The authors focus on interactive and non-deterministic applications such as mobile games to demonstrate the flexibility and robusteness of their methodology.&lt;/p&gt;

&lt;p&gt;Their methodology is based on the use of the use of hardware performance counters present in most modern CPU architectures. They use these counters to sample key workload metrics of the target application under normal use, such as the total number of CPU instructions, memory instructions, branch instructions, etc.&lt;/p&gt;

&lt;figure class=&quot;figure&quot;&gt;
  &lt;img src=&quot;/bibliography/assets/images/workloadsynthesis_metrics.gif&quot; alt=&quot;Recorded metrics&quot; /&gt;
  
  &lt;figcaption&gt;Recorded performance counter events.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;From these sampled values, a statistical representation of the workload is then generated, describing the probability distribution functions for each event count in each sampling interval.&lt;/p&gt;

&lt;p&gt;The authors then introduce the notion of “&lt;em&gt;kernel functions&lt;/em&gt;”: brief sections of code (in this case, written in plain C) which generate &lt;em&gt;empty&lt;/em&gt; load - i.e. these functions have no purpose other than this - for specific counter events . For instance, they present functions for incrementing the ALU event count, the branch miss count, and so on. 
In conjunction with the previously mentioned statistical profile, these kernel functions allow the researchers to synthesize a &lt;em&gt;fake&lt;/em&gt; workload which has an extremely similar profile as the &lt;em&gt;real&lt;/em&gt; one.&lt;/p&gt;

&lt;figure class=&quot;figure&quot;&gt;
  &lt;img src=&quot;/bibliography/assets/images/workloadsynthesis_results.gif&quot; alt=&quot;Results&quot; /&gt;
  
  &lt;figcaption&gt;Results: real vs. synthetic workloads.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;The approach has some limitations and challenges though. To begin with, the authors were only able to apply it to single-threaded applications due to limitations on the ARMv7 chipset they were working with (although they claim to be able to extend it to multi-threaded applications running on newer Intel processors). Additionally, the &lt;em&gt;kernel functions&lt;/em&gt; they present are not completely orthogonal (i.e. their effects are not isolated to single performance counter events, but often modify additional ones). This leads to a complicated synthesis algorithm and a decrease in the accuracy of the generated workload compared to the real one.&lt;/p&gt;

&lt;p&gt;All in all, this article presents an interesting and straightforward methodology for workload sythesis, that might be applicable to wearable cognitive assistance.&lt;/p&gt;
</description>
        <pubDate>Fri, 01 Jun 2018 00:00:00 +0000</pubDate>
        <link>http://molguin92.github.io/bibliography/bibliography/2018/workload-synthesis-generating-benchmark-workloads-from-statistical-execution-profile/</link>
        <guid isPermaLink="true">http://molguin92.github.io/bibliography/bibliography/2018/workload-synthesis-generating-benchmark-workloads-from-statistical-execution-profile/</guid>
        
        
      </item>
    
  </channel>
</rss>
